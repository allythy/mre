{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MRE Um pacote em Python para fazer express\u00e3o regular (RegEx). Possui o objetivo de transformar a cria\u00e7\u00e3o de um RegEx em algo mais f\u00e1cil de se ler. Instala\u00e7\u00e3o do MRE Install the MRE package using pip: pip install mre","title":"Instala\u00e7\u00e3o"},{"location":"#mre","text":"Um pacote em Python para fazer express\u00e3o regular (RegEx). Possui o objetivo de transformar a cria\u00e7\u00e3o de um RegEx em algo mais f\u00e1cil de se ler.","title":"MRE"},{"location":"#instalacao-do-mre","text":"Install the MRE package using pip: pip install mre","title":"Instala\u00e7\u00e3o do MRE"},{"location":"guia-de-uso/","text":"Classes Regex Quantifier Set Group Anchor Helper Range Regex Essa \u00e9 a classe pai de todas as classes do pacote, o RegEx que se est\u00e1 manipulando fica na vari\u00e1vel self.rgx . Seu construtor pode receber qualquer quantidade de entradas, por\u00e9m espera-se que sejam dos tipos: str , int e a pr\u00f3pria classe Regex . Para entender melhor: str : concatena \u00e0 vari\u00e1vel self.rgx ; int : realiza backreferences ; Regex : concatena o valor armazenado em self.rgx do objeto que se recebe na vari\u00e1vel self.rgx do objeto que est\u00e1 recebendo. Formas de se declarar um Regex : from mre import Regex, Group rgx_one = Regex(\"Hello world\") # Hello world rgx_two = Regex(\"Hello\", \" world\") # Hello world rgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\") # Hello world rgx_four = Regex('<', Group('h[1-6]'), '>') # <(h[1-6])> rgx_five = Regex('<', Regex.SLASH, 1, '>') # <\\/\\1> Constantes Constantes presentes na classe Regex : Constante Valor ANY . DOT \\\\. DIGIT \\\\d WHITESPACE \\\\s WORD_CHARS \\\\w SLASH \\\\/. NOT_DIGIT \\\\D NOT_WHITESPACE \\\\S NOT_WORD_CHARS \\\\W ZERO_OR_ONE ? ZERO_OR_MULTIPLE * ONE_OR_MULTIPLE + HYPHEN \\\\- M\u00e9todos Al\u00e9m das fun\u00e7\u00f5es, tamb\u00e9m haver\u00e1 a descri\u00e7\u00e3o das sobrecargas. __str__ Retorna o valor salvo em self.rgx . from mre import Regex regex = Regex(\"Hello world\") print(regex) # \"Hello world\" __eq__ A compara\u00e7\u00e3o pode ser entre str ou Regex : - == str : compara self.rgx ao valor da vari\u00e1vel recebida; - == Regex : compara self.rgx (acessado atrav\u00e9s do m\u00e9todo get ) ao valor da vari\u00e1vel self.rgx do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo get ). from mre import Regex regex_one = Regex(\"Hello world\") print(regex_one == \"Hello world\") # True print(regex_one == \"Hello world!\") # False print(regex_one == Regex(\"Hello world\")) # True print(regex_one == Regex(\"Hello world!\")) # False __iadd__ Espera-se vari\u00e1veis de dois tipos: str e Regex . Para entender melhor: += str : concatena self.rgx ao valor da vari\u00e1vel recebida; += Regex : concatena self.rgx ao valor da vari\u00e1vel self.rgx do objeto recebido (acessado atrav\u00e9s do m\u00e9todo get ). Essa sobrecarga altera diretamente a vari\u00e1vel self.rgx , sendo assim nos casos de opera\u00e7\u00e3o, por exemplo, em um objeto Set , ir\u00e1 alterar o valor entre os colchetes. from mre import Regex, Set regex = Regex(\"Hello\") regex += \" world\" print(regex) # \"Hello world\" regex_set = Set(\"Hello\") # [Hello] regex_set += \" world\" print(regex_set) # \"[Hello world]\" __add__ Espera-se vari\u00e1veis de dois tipos: str e Regex . Diferentemente da sobrecarga __iadd__ , essa sobrecarga retorna um novo objeto Regex . + str : concatena self.rgx (acessado atrav\u00e9s do m\u00e9todo get ) ao valor da vari\u00e1vel recebida; + Regex : concatena self.rgx (acessado atrav\u00e9s do m\u00e9todo get ) ao valor da vari\u00e1vel self.rgx do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo get ). from mre import Regex regex_one = Regex(\"Hello\") + \" \" + Regex(\"world\") regex_two = Regex(\"Hello\") + Regex(\" world\") print(regex_one) # \"Hello world\" print(regex_two) # \"Hello world\" get Retorna o valor armazenado em self.rgx . from mre import Regex regex = Regex(\"Valor armazenado\") print(regex.get()) # \"Valor armazenado\" quantifier Possui os seguintes par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o n int 0 m int 0 without_maximum bool False Serve para quantificar as vezes que o RegEx deve/pode aparecer (de n at\u00e9 m ). Retorna um novo objeto Regex . Em casos espec\u00edficos, h\u00e1 a adi\u00e7\u00e3o de um s\u00edmbolo. Esses casos s\u00e3o: n m without_maximum S\u00edmbolo Acesso 0 1 - ? Regex.ZERO_OR_ONE 0 - True * Regex.ZERO_OR_MULTIPLE 1 - True + Regex.ONE_OR_MULTIPLE Al\u00e9m desses casos espec\u00edficos, a quantifica\u00e7\u00e3o poder\u00e1 ocorrer das formas: - {n} : deve ocorrer n vezes; - {n, m} : pode ocorrer de n at\u00e9 m vezes. from mre import Regex digits = Regex(\"[0-9]\") print(digits.quantifier(3)) # \"[0-9]{3}\" print(digits.quantifier(3, 5)) # \"[0-9]{3,5}\" print(digits.quantifier(0, 1)) # \"[0-9]?\" print(digits.quantifier(0, without_maximum=True)) # \"[0-9]*\" print(digits.quantifier(1, without_maximum=True)) # \"[0-9]+\" backreferences Possui um par\u00e2metro do tipo int ( group_n ) que serve para indicar qual grupo se deseja realizar a backreference . Retorna um Regex que realiza backreferences ao grupo indicado. Um meio alternativo de chamar esse m\u00e9todo \u00e9 inserindo um int no construtor. from mre import Regex regex_one = Regex().backreferences(1) regex_two = Regex(2) print(regex_one) # \"\\1\" print(regex_two) # \"\\2\" Quantifier Essa classe serve como uma alternativa a chamada do m\u00e9todo Regex.quantifier . Seu construtor recebe 4 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o regex str , int , Regex \"\" n int 0 m int 0 without_maximum bool False O primeiro \u00e9 referente ao RegEx que se deseja construir, os 3 restantes s\u00e3o para a chamada do m\u00e9todo Regex.quantifier . from mre import Regex, Quantifier digits_one = Regex(\"[0-9]\").quantifier(3, 5) digits_two = Quantifier(\"[0-9]\", 3, 5) print(digits_one) # \"[0-9]{3,5}\" print(digits_two) # \"[0-9]{3,5}\" Set Essa classe representa um conjunto no RegEx. Seu construtor \u00e9 o mesmo da classe Regex . from mre import Set regex_set = Set(\"0-9\") print(regex_set) # \"[0-9]\" print(regex_set.quantifier(3)) # \"[0-9]{3}\" M\u00e9todos Essa classe herda os m\u00e9todos da classe Regex , sobrescrevendo apenas os m\u00e9todos a seguir. get Retorna o valor armazenado em self.rgx , mas entre colchetes. from mre import Set regex_set = Set(\"0-9\") print(regex_set.get()) # \"[0-9]\" quantifier Retorna um novo objeto Regex com o quantificador referente ao conjunto. from mre import Set regex_set = Set(\"0-9\") print(regex_set) # \"[0-9]\" print(regex_set.quantifier(3)) # \"[0-9]{3}\" print(type(regex_set)) # <class 'mre.Set.Set'> print(type(regex_set.quantifier(3))) # <class 'mre.Regex.Regex'> Group Essa classe representa um grupo no RegEx. Seu construtor recebe 2 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o regex str , int , Regex \"\" non_capturing bool False Se o argumento referente a non_capturing for True , ser\u00e1 adicionado os s\u00edmbolos que indicam que a RegEx Engine n\u00e3o deve retornar o valor daquele grupo ( ?: ). from mre import Group regex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>') regex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True) print(regex_group_one) # (<h1>)([\\w\\s]+)(</h1>) print(regex_group_two) # (?:<h1>)([\\w\\s]+)(?:</h1>) M\u00e9todos Essa classe herda os m\u00e9todos da classe Regex , sobrescrevendo apenas os m\u00e9todos a seguir. get Retorna o valor armazenado em self.rgx , mas entre par\u00eanteses. from mre import Group regex_group_one = Group(\"<h1>\") regex_group_two = Group(\"</h1>\", True) print(regex_group_one.get()) # \"(<h1>)\" print(regex_group_two.get()) # \"(?:</h1>)\" quantifier Retorna um novo objeto Regex com o quantificador referente ao grupo. from mre import Group regex_group = Group(\"<h1>\") print(regex_group) # \"(<h1>)\" print(regex_group.quantifier(3)) # \"(<h1>){3}\" print(type(regex_group)) # <class 'mre.Group.Group'> print(type(regex_group.quantifier(3))) # <class 'mre.Regex.Regex'> Anchor Essa classe representa um RegEx com \u00e2ncora (o RegEx deve come\u00e7ar e terminar como foi definido). Seu construtor recebe 2 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o regex str , int , Regex \"\" negate bool False Se o argumento referente a negate for True , ser\u00e1 adicionado os s\u00edmbolos do inverso do padr\u00e3o, ou seja, a RegEx n\u00e3o deve come\u00e7ar e terminar como definido. from mre import Anchor regex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\") regex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True) print(regex_anchor_one) # \"^\\d{4}-\\w+.txt$\" print(regex_anchor_two) # \"\\b\\d{4}-\\w+.txt\\B\" M\u00e9todos Essa classe herda os m\u00e9todos da classe Regex , sobrescrevendo apenas os m\u00e9todos a seguir. get Retorna o valor armazenado em self.rgx , mas entre par\u00eanteses. from mre import Anchor regex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\") regex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True) print(regex_anchor_one.get()) # \"^<h1>Hello world</h1>$\" print(regex_anchor_two.get()) # \"\\b<h1>Hello world</h1>\\B\" helper.Range Essa classe serve para ajudar na cria\u00e7\u00e3o de um RegEx que indique uma classe de caracteres a partir de um range . Seu construtor recebe 2 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o minimum str , int 0 maximum str , int \"z\" Idealmente usar essa classe junto a classe Set , pois dentro de um conjunto, o h\u00edfen possui um valor \"m\u00e1gico\" que o permite dar essa fun\u00e7\u00e3o de atribuir range , fora do conjunto o h\u00edfen tem apenas valor de h\u00edfen. Logo, se voc\u00ea quiser, por exemplo, todas as letras min\u00fasculas, deve usar [a-z] e n\u00e3o apenas a-z , pois assim voc\u00ea est\u00e1 apenas dizendo que quer a , - e z . from mre.helper import Range # Todos os d\u00edgitos digits = Range(0, 9) # Todas as letras letters = Range('A', 'z') print(digits) # \"0-9\" print(letters) # \"A-z\" M\u00e9todos Essa classe herda os m\u00e9todos da classe Regex , al\u00e9m de possuir seus pr\u00f3prios m\u00e9todos. digits Possui 2 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o minimum int 0 maximum int 9 Retorna um range que define os d\u00edgitos entre minimum e maximum . from mre.helper import Range regex_range_one = Range(0, 9) regex_range_two = Range().digits() regex_range_three = Range(0, 6) regex_range_four = Range().digits(0, 6) print(regex_range_one) # \"0-9\" print(regex_range_two) # \"0-9\" print(regex_range_three) # \"0-6\" print(regex_range_four) # \"0-6\" letters Possui 4 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o minimum chr A maximum chr z uppercase bool False lowercase bool False Retorna um range que define as letras entre minimum e maximum . from mre.helper import Range # Todas as letras regex_range_one = Range('A', 'z') regex_range_two = Range().letters() regex_range_three = Range().letters('A', 'z') regex_range_four = Range().letters(uppercase=True, lowercase=True) # Todas as letras mai\u00fasculas regex_range_five = Range().letters(uppercase=True) # Todas as letras min\u00fasculas regex_range_six = Range().letters(lowercase=True) print(regex_range_one) # \"A-z\" print(regex_range_two) # \"A-z\" print(regex_range_three) # \"A-z\" print(regex_range_four) # \"A-z\" print(regex_range_five) # \"A-Z\" print(regex_range_six) # \"a-z\" Exemplos 2 formas de fazer o RegEx de CEP ( [0-9]{5}-?[0-9]{3} ) from mre import Regex, Set # Todos os d\u00edgitos digits = Set(Regex(\"0-9\")) rgx_cep = Regex( digits.quantifier(5), Regex(\"-\").quantifier(0, 1), digits.quantifier(3), ) from mre import Regex, Quantifier, Set from mre.helper import Range # Todos os d\u00edgitos [0-9] digits = Set(Range().digits()) # O h\u00edfen pode aparecer nenhuma ou uma vez hyphen = Quantifier(\"-\", 0, 1) rgx_cep = Regex( digits.quantifier(5), hyphen, digits.quantifier(3), ) RegEx de CPF ( [0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2} ): from mre import Regex, Set from mre.helper import Range # Todos os d\u00edgitos all_digits = Set(Range(0, 9)) # O ponto pode aparecer nenhuma ou uma vez dot = Regex(Regex.DOT).quantifier(0, 1) # O h\u00edfen pode aparecer nenhuma ou uma vez hyphen = Regex('-').quantifier(0, 1) rgx_cpf = Regex( all_digits.quantifier(3), dot, all_digits.quantifier(3), dot, all_digits.quantifier(3), hyphen, all_digits.quantifier(2), ) RegEx de CNPJ ( \\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2} ): from mre import Regex, Quantifier # Todos os d\u00edgitos digits = Regex(Regex.DIGIT) # O ponto pode aparecer nenhuma ou uma vez dot = Regex(Regex.DOT).quantifier(0, 1) # A barra pode aparecer nenhuma ou uma vez slash = Regex(Regex.SLASH).quantifier(0, 1) # O h\u00edfen pode aparecer nenhuma ou uma vez hyphen = Quantifier(\"-\", 0, 1) rgx_cnpj = Regex( digits.quantifier(2), dot, digits.quantifier(3), dot, digits.quantifier(3), slash, digits.quantifier(4), hyphen, digits.quantifier(2), )","title":"Guia de uso"},{"location":"guia-de-uso/#classes","text":"Regex Quantifier Set Group Anchor Helper Range","title":"Classes"},{"location":"guia-de-uso/#regex","text":"Essa \u00e9 a classe pai de todas as classes do pacote, o RegEx que se est\u00e1 manipulando fica na vari\u00e1vel self.rgx . Seu construtor pode receber qualquer quantidade de entradas, por\u00e9m espera-se que sejam dos tipos: str , int e a pr\u00f3pria classe Regex . Para entender melhor: str : concatena \u00e0 vari\u00e1vel self.rgx ; int : realiza backreferences ; Regex : concatena o valor armazenado em self.rgx do objeto que se recebe na vari\u00e1vel self.rgx do objeto que est\u00e1 recebendo. Formas de se declarar um Regex : from mre import Regex, Group rgx_one = Regex(\"Hello world\") # Hello world rgx_two = Regex(\"Hello\", \" world\") # Hello world rgx_three = Regex(\"Hello\") + \" \" + Regex(\"world\") # Hello world rgx_four = Regex('<', Group('h[1-6]'), '>') # <(h[1-6])> rgx_five = Regex('<', Regex.SLASH, 1, '>') # <\\/\\1>","title":"Regex"},{"location":"guia-de-uso/#constantes","text":"Constantes presentes na classe Regex : Constante Valor ANY . DOT \\\\. DIGIT \\\\d WHITESPACE \\\\s WORD_CHARS \\\\w SLASH \\\\/. NOT_DIGIT \\\\D NOT_WHITESPACE \\\\S NOT_WORD_CHARS \\\\W ZERO_OR_ONE ? ZERO_OR_MULTIPLE * ONE_OR_MULTIPLE + HYPHEN \\\\-","title":"Constantes"},{"location":"guia-de-uso/#metodos","text":"Al\u00e9m das fun\u00e7\u00f5es, tamb\u00e9m haver\u00e1 a descri\u00e7\u00e3o das sobrecargas.","title":"M\u00e9todos"},{"location":"guia-de-uso/#9595str9595","text":"Retorna o valor salvo em self.rgx . from mre import Regex regex = Regex(\"Hello world\") print(regex) # \"Hello world\"","title":"__str__"},{"location":"guia-de-uso/#9595eq9595","text":"A compara\u00e7\u00e3o pode ser entre str ou Regex : - == str : compara self.rgx ao valor da vari\u00e1vel recebida; - == Regex : compara self.rgx (acessado atrav\u00e9s do m\u00e9todo get ) ao valor da vari\u00e1vel self.rgx do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo get ). from mre import Regex regex_one = Regex(\"Hello world\") print(regex_one == \"Hello world\") # True print(regex_one == \"Hello world!\") # False print(regex_one == Regex(\"Hello world\")) # True print(regex_one == Regex(\"Hello world!\")) # False","title":"__eq__"},{"location":"guia-de-uso/#9595iadd9595","text":"Espera-se vari\u00e1veis de dois tipos: str e Regex . Para entender melhor: += str : concatena self.rgx ao valor da vari\u00e1vel recebida; += Regex : concatena self.rgx ao valor da vari\u00e1vel self.rgx do objeto recebido (acessado atrav\u00e9s do m\u00e9todo get ). Essa sobrecarga altera diretamente a vari\u00e1vel self.rgx , sendo assim nos casos de opera\u00e7\u00e3o, por exemplo, em um objeto Set , ir\u00e1 alterar o valor entre os colchetes. from mre import Regex, Set regex = Regex(\"Hello\") regex += \" world\" print(regex) # \"Hello world\" regex_set = Set(\"Hello\") # [Hello] regex_set += \" world\" print(regex_set) # \"[Hello world]\"","title":"__iadd__"},{"location":"guia-de-uso/#9595add9595","text":"Espera-se vari\u00e1veis de dois tipos: str e Regex . Diferentemente da sobrecarga __iadd__ , essa sobrecarga retorna um novo objeto Regex . + str : concatena self.rgx (acessado atrav\u00e9s do m\u00e9todo get ) ao valor da vari\u00e1vel recebida; + Regex : concatena self.rgx (acessado atrav\u00e9s do m\u00e9todo get ) ao valor da vari\u00e1vel self.rgx do objeto recebido (tamb\u00e9m acessado atrav\u00e9s do m\u00e9todo get ). from mre import Regex regex_one = Regex(\"Hello\") + \" \" + Regex(\"world\") regex_two = Regex(\"Hello\") + Regex(\" world\") print(regex_one) # \"Hello world\" print(regex_two) # \"Hello world\"","title":"__add__"},{"location":"guia-de-uso/#get","text":"Retorna o valor armazenado em self.rgx . from mre import Regex regex = Regex(\"Valor armazenado\") print(regex.get()) # \"Valor armazenado\"","title":"get"},{"location":"guia-de-uso/#quantifier","text":"Possui os seguintes par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o n int 0 m int 0 without_maximum bool False Serve para quantificar as vezes que o RegEx deve/pode aparecer (de n at\u00e9 m ). Retorna um novo objeto Regex . Em casos espec\u00edficos, h\u00e1 a adi\u00e7\u00e3o de um s\u00edmbolo. Esses casos s\u00e3o: n m without_maximum S\u00edmbolo Acesso 0 1 - ? Regex.ZERO_OR_ONE 0 - True * Regex.ZERO_OR_MULTIPLE 1 - True + Regex.ONE_OR_MULTIPLE Al\u00e9m desses casos espec\u00edficos, a quantifica\u00e7\u00e3o poder\u00e1 ocorrer das formas: - {n} : deve ocorrer n vezes; - {n, m} : pode ocorrer de n at\u00e9 m vezes. from mre import Regex digits = Regex(\"[0-9]\") print(digits.quantifier(3)) # \"[0-9]{3}\" print(digits.quantifier(3, 5)) # \"[0-9]{3,5}\" print(digits.quantifier(0, 1)) # \"[0-9]?\" print(digits.quantifier(0, without_maximum=True)) # \"[0-9]*\" print(digits.quantifier(1, without_maximum=True)) # \"[0-9]+\"","title":"quantifier"},{"location":"guia-de-uso/#backreferences","text":"Possui um par\u00e2metro do tipo int ( group_n ) que serve para indicar qual grupo se deseja realizar a backreference . Retorna um Regex que realiza backreferences ao grupo indicado. Um meio alternativo de chamar esse m\u00e9todo \u00e9 inserindo um int no construtor. from mre import Regex regex_one = Regex().backreferences(1) regex_two = Regex(2) print(regex_one) # \"\\1\" print(regex_two) # \"\\2\"","title":"backreferences"},{"location":"guia-de-uso/#quantifier_1","text":"Essa classe serve como uma alternativa a chamada do m\u00e9todo Regex.quantifier . Seu construtor recebe 4 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o regex str , int , Regex \"\" n int 0 m int 0 without_maximum bool False O primeiro \u00e9 referente ao RegEx que se deseja construir, os 3 restantes s\u00e3o para a chamada do m\u00e9todo Regex.quantifier . from mre import Regex, Quantifier digits_one = Regex(\"[0-9]\").quantifier(3, 5) digits_two = Quantifier(\"[0-9]\", 3, 5) print(digits_one) # \"[0-9]{3,5}\" print(digits_two) # \"[0-9]{3,5}\"","title":"Quantifier"},{"location":"guia-de-uso/#set","text":"Essa classe representa um conjunto no RegEx. Seu construtor \u00e9 o mesmo da classe Regex . from mre import Set regex_set = Set(\"0-9\") print(regex_set) # \"[0-9]\" print(regex_set.quantifier(3)) # \"[0-9]{3}\"","title":"Set"},{"location":"guia-de-uso/#metodos_1","text":"Essa classe herda os m\u00e9todos da classe Regex , sobrescrevendo apenas os m\u00e9todos a seguir.","title":"M\u00e9todos"},{"location":"guia-de-uso/#get_1","text":"Retorna o valor armazenado em self.rgx , mas entre colchetes. from mre import Set regex_set = Set(\"0-9\") print(regex_set.get()) # \"[0-9]\"","title":"get"},{"location":"guia-de-uso/#quantifier_2","text":"Retorna um novo objeto Regex com o quantificador referente ao conjunto. from mre import Set regex_set = Set(\"0-9\") print(regex_set) # \"[0-9]\" print(regex_set.quantifier(3)) # \"[0-9]{3}\" print(type(regex_set)) # <class 'mre.Set.Set'> print(type(regex_set.quantifier(3))) # <class 'mre.Regex.Regex'>","title":"quantifier"},{"location":"guia-de-uso/#group","text":"Essa classe representa um grupo no RegEx. Seu construtor recebe 2 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o regex str , int , Regex \"\" non_capturing bool False Se o argumento referente a non_capturing for True , ser\u00e1 adicionado os s\u00edmbolos que indicam que a RegEx Engine n\u00e3o deve retornar o valor daquele grupo ( ?: ). from mre import Group regex_group_one = Group('<h1>') + Group('[\\w\\s]+') + Group('</h1>') regex_group_two = Group('<h1>', True) + Group('[\\w\\s]+') + Group('</h1>', True) print(regex_group_one) # (<h1>)([\\w\\s]+)(</h1>) print(regex_group_two) # (?:<h1>)([\\w\\s]+)(?:</h1>)","title":"Group"},{"location":"guia-de-uso/#metodos_2","text":"Essa classe herda os m\u00e9todos da classe Regex , sobrescrevendo apenas os m\u00e9todos a seguir.","title":"M\u00e9todos"},{"location":"guia-de-uso/#get_2","text":"Retorna o valor armazenado em self.rgx , mas entre par\u00eanteses. from mre import Group regex_group_one = Group(\"<h1>\") regex_group_two = Group(\"</h1>\", True) print(regex_group_one.get()) # \"(<h1>)\" print(regex_group_two.get()) # \"(?:</h1>)\"","title":"get"},{"location":"guia-de-uso/#quantifier_3","text":"Retorna um novo objeto Regex com o quantificador referente ao grupo. from mre import Group regex_group = Group(\"<h1>\") print(regex_group) # \"(<h1>)\" print(regex_group.quantifier(3)) # \"(<h1>){3}\" print(type(regex_group)) # <class 'mre.Group.Group'> print(type(regex_group.quantifier(3))) # <class 'mre.Regex.Regex'>","title":"quantifier"},{"location":"guia-de-uso/#anchor","text":"Essa classe representa um RegEx com \u00e2ncora (o RegEx deve come\u00e7ar e terminar como foi definido). Seu construtor recebe 2 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o regex str , int , Regex \"\" negate bool False Se o argumento referente a negate for True , ser\u00e1 adicionado os s\u00edmbolos do inverso do padr\u00e3o, ou seja, a RegEx n\u00e3o deve come\u00e7ar e terminar como definido. from mre import Anchor regex_anchor_one = Anchor(\"\\\\d{4}-\\\\w+.txt\") regex_anchor_two = Anchor(\"\\\\d{4}-\\\\w+.txt\", True) print(regex_anchor_one) # \"^\\d{4}-\\w+.txt$\" print(regex_anchor_two) # \"\\b\\d{4}-\\w+.txt\\B\"","title":"Anchor"},{"location":"guia-de-uso/#metodos_3","text":"Essa classe herda os m\u00e9todos da classe Regex , sobrescrevendo apenas os m\u00e9todos a seguir.","title":"M\u00e9todos"},{"location":"guia-de-uso/#get_3","text":"Retorna o valor armazenado em self.rgx , mas entre par\u00eanteses. from mre import Anchor regex_anchor_one = Anchor(\"<h1>Hello world<\\/h1>\") regex_anchor_two = Anchor(\"<h1>Hello world<\\/h1>\", True) print(regex_anchor_one.get()) # \"^<h1>Hello world</h1>$\" print(regex_anchor_two.get()) # \"\\b<h1>Hello world</h1>\\B\"","title":"get"},{"location":"guia-de-uso/#helperrange","text":"Essa classe serve para ajudar na cria\u00e7\u00e3o de um RegEx que indique uma classe de caracteres a partir de um range . Seu construtor recebe 2 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o minimum str , int 0 maximum str , int \"z\" Idealmente usar essa classe junto a classe Set , pois dentro de um conjunto, o h\u00edfen possui um valor \"m\u00e1gico\" que o permite dar essa fun\u00e7\u00e3o de atribuir range , fora do conjunto o h\u00edfen tem apenas valor de h\u00edfen. Logo, se voc\u00ea quiser, por exemplo, todas as letras min\u00fasculas, deve usar [a-z] e n\u00e3o apenas a-z , pois assim voc\u00ea est\u00e1 apenas dizendo que quer a , - e z . from mre.helper import Range # Todos os d\u00edgitos digits = Range(0, 9) # Todas as letras letters = Range('A', 'z') print(digits) # \"0-9\" print(letters) # \"A-z\"","title":"helper.Range"},{"location":"guia-de-uso/#metodos_4","text":"Essa classe herda os m\u00e9todos da classe Regex , al\u00e9m de possuir seus pr\u00f3prios m\u00e9todos.","title":"M\u00e9todos"},{"location":"guia-de-uso/#digits","text":"Possui 2 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o minimum int 0 maximum int 9 Retorna um range que define os d\u00edgitos entre minimum e maximum . from mre.helper import Range regex_range_one = Range(0, 9) regex_range_two = Range().digits() regex_range_three = Range(0, 6) regex_range_four = Range().digits(0, 6) print(regex_range_one) # \"0-9\" print(regex_range_two) # \"0-9\" print(regex_range_three) # \"0-6\" print(regex_range_four) # \"0-6\"","title":"digits"},{"location":"guia-de-uso/#letters","text":"Possui 4 par\u00e2metros: Par\u00e2metro Tipo Valor padr\u00e3o minimum chr A maximum chr z uppercase bool False lowercase bool False Retorna um range que define as letras entre minimum e maximum . from mre.helper import Range # Todas as letras regex_range_one = Range('A', 'z') regex_range_two = Range().letters() regex_range_three = Range().letters('A', 'z') regex_range_four = Range().letters(uppercase=True, lowercase=True) # Todas as letras mai\u00fasculas regex_range_five = Range().letters(uppercase=True) # Todas as letras min\u00fasculas regex_range_six = Range().letters(lowercase=True) print(regex_range_one) # \"A-z\" print(regex_range_two) # \"A-z\" print(regex_range_three) # \"A-z\" print(regex_range_four) # \"A-z\" print(regex_range_five) # \"A-Z\" print(regex_range_six) # \"a-z\"","title":"letters"},{"location":"guia-de-uso/#exemplos","text":"2 formas de fazer o RegEx de CEP ( [0-9]{5}-?[0-9]{3} ) from mre import Regex, Set # Todos os d\u00edgitos digits = Set(Regex(\"0-9\")) rgx_cep = Regex( digits.quantifier(5), Regex(\"-\").quantifier(0, 1), digits.quantifier(3), ) from mre import Regex, Quantifier, Set from mre.helper import Range # Todos os d\u00edgitos [0-9] digits = Set(Range().digits()) # O h\u00edfen pode aparecer nenhuma ou uma vez hyphen = Quantifier(\"-\", 0, 1) rgx_cep = Regex( digits.quantifier(5), hyphen, digits.quantifier(3), ) RegEx de CPF ( [0-9]{3}.?[0-9]{3}.?[0-9]{3}-?[0-9]{2} ): from mre import Regex, Set from mre.helper import Range # Todos os d\u00edgitos all_digits = Set(Range(0, 9)) # O ponto pode aparecer nenhuma ou uma vez dot = Regex(Regex.DOT).quantifier(0, 1) # O h\u00edfen pode aparecer nenhuma ou uma vez hyphen = Regex('-').quantifier(0, 1) rgx_cpf = Regex( all_digits.quantifier(3), dot, all_digits.quantifier(3), dot, all_digits.quantifier(3), hyphen, all_digits.quantifier(2), ) RegEx de CNPJ ( \\d{2}\\.?\\d{3}\\.?\\d{3}\\/?\\d{4}\\-?\\d{2} ): from mre import Regex, Quantifier # Todos os d\u00edgitos digits = Regex(Regex.DIGIT) # O ponto pode aparecer nenhuma ou uma vez dot = Regex(Regex.DOT).quantifier(0, 1) # A barra pode aparecer nenhuma ou uma vez slash = Regex(Regex.SLASH).quantifier(0, 1) # O h\u00edfen pode aparecer nenhuma ou uma vez hyphen = Quantifier(\"-\", 0, 1) rgx_cnpj = Regex( digits.quantifier(2), dot, digits.quantifier(3), dot, digits.quantifier(3), slash, digits.quantifier(4), hyphen, digits.quantifier(2), )","title":"Exemplos"},{"location":"idiomas/","text":"Idiomas Portugu\u00eas, Brasiil","title":"Idiomas"},{"location":"idiomas/#idiomas","text":"Portugu\u00eas, Brasiil","title":"Idiomas"},{"location":"licenca/","text":"MIT License Copyright (c) 2018 The Python Packaging Authority Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licen\u00e7a"},{"location":"licenca/#mit-license","text":"Copyright (c) 2018 The Python Packaging Authority Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT License"},{"location":"sobre/","text":"This a simple package to make regular expression in Python.","title":"Sobre"}]}